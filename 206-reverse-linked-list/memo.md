# ステップ１

連結リストを逆順にする。

（メタ的であまり良くないが）スタックの分類にある問題なので各ノードをスタックに積み上げていって、
スタックの上から順に取り出してスタックの一番上にあるノードにnextを繋ぎかえる
ということをすればいい。
ただしスタックが空になったらそれはNoneに繋ぐことに注意する。

上の解法はループで解くことを想定したが、Followupに反復と再帰両方実装できるか、と書いてあるので再帰も考えてみる。
再帰の場合はそれ自体がスタックになるので、

- 再帰呼び出しをする
- 今見ているノードを前のノードに繋ぎかえる

という感じで解けるはず。

一応２パターン実装できた。

# ステップ２

## iterative

なんかメタでスタック使うことに引っ張られてたけどそもそも再帰でやったように今見ているノードと一個前のノードを持ちながら
順番に後ろに繋ぎかえていくだけで良い気がした。

めちゃくちゃシンプルになったし、こっちのほうが自然かなという気がする。

## recursive

iterativeでやったようにpreviousを返せば場合分けが不要になりそう。

気になるのは引数の順序が`node, previous`がいいか`previous, node`がいいか。
時系列を考えると`previous, node`のほうが自然な気もするが、
今着目しているのはnodeのほうであるのでその主役を前に持ってくる`node, previous`も良い気がしている。
後者の考えで`node, previous`にしているが、この辺はレビューで意見を貰えればありがたい。

## 他の人のコードを見る

https://github.com/5103246/LeetCode_Arai60/pull/7/files

再帰のほうは引数２つ渡さなくても`node.next.next = node`という繋ぎかえでも逆順にできるのか。確かに。
一方で「ややトリッキー」という声も。確かに私も少し理解に時間がかかった。

https://github.com/maeken4/Arai60/pull/7#discussion_r2118170691

私が`previous`としているところを`reversed_head`としているコードもあった。
最終的には確かに逆順リストの先頭になるのだけど、途中ではそうではないのでどうなんだろうという気持ちがある。

# ステップ３

iterativeのほうを選択し３回連続で通せたので一旦完了。

# ステップ４

`node.next.next = node`を使う再帰も書いてみた。

# ステップ５

> ただ LeetCode の再帰の最大数を`sys.getrecursionlimit()`で確認すると 55,000 になっていたので、今回は RecursionError を考慮しなくて良い。
https://github.com/tarinaihitori/leetcode/pull/6/files#diff-f1530fc1072ee1f0b7de99a2e5236992c72355da69982c8ca516fcfba7c57927R46

そうだったのか。

https://github.com/goto-untrapped/Arai60/pull/27#discussion_r1638693522

再帰で解くにしても２つの考え方がある。今回私がやったのは「何も渡さずに、6番目以降をひっくり返したものを返してもらう」
のほうだったが「５番目以前をひっくりかえしたものを渡して、全部ひっくりかえしたものを返してもらう」もやってみる。

> だから、「解体中の先頭」「構築中の先頭」が素直な名前の付け方だと思うんですよ。「古い鎖」「新しい鎖」でもなんでもいいですが。
> previous, current は、「作業中に私が注目していたやつとその前に注目していたやつ」ということですが、それは人には伝わりませんね。

確かに今回はちょっと名前が単純すぎたかもしれない。これは名前をつけるのをサボったというより、
すんなり解けるからと機械的に解いてしまったためこのコードの各処理の意味について深く考えなかったからという面もありそう。

２通りの再帰を実装してみた。
