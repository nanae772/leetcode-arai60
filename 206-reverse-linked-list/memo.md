# ステップ１

連結リストを逆順にする。

（メタ的であまり良くないが）スタックの分類にある問題なので各ノードをスタックに積み上げていって、
スタックの上から順に取り出してスタックの一番上にあるノードにnextを繋ぎかえる
ということをすればいい。
ただしスタックが空になったらそれはNoneに繋ぐことに注意する。

上の解法はループで解くことを想定したが、Followupに反復と再帰両方実装できるか、と書いてあるので再帰も考えてみる。
再帰の場合はそれ自体がスタックになるので、

- 再帰呼び出しをする
- 今見ているノードを前のノードに繋ぎかえる

という感じで解けるはず。

一応２パターン実装できた。

# ステップ２

## iterative

なんかメタでスタック使うことに引っ張られてたけどそもそも再帰でやったように今見ているノードと一個前のノードを持ちながら
順番に後ろに繋ぎかえていくだけで良い気がした。

めちゃくちゃシンプルになったし、こっちのほうが自然かなという気がする。

## recursive

iterativeでやったようにpreviousを返せば場合分けが不要になりそう。

気になるのは引数の順序が`node, previous`がいいか`previous, node`がいいか。
時系列を考えると`previous, node`のほうが自然な気もするが、
今着目しているのはnodeのほうであるのでその主役を前に持ってくる`node, previous`も良い気がしている。
後者の考えで`node, previous`にしているが、この辺はレビューで意見を貰えればありがたい。

## 他の人のコードを見る

https://github.com/5103246/LeetCode_Arai60/pull/7/files

再帰のほうは引数２つ渡さなくても`node.next.next = node`という繋ぎかえでも逆順にできるのか。確かに。
一方で「ややトリッキー」という声も。確かに私も少し理解に時間がかかった。

https://github.com/maeken4/Arai60/pull/7#discussion_r2118170691

私が`previous`としているところを`reversed_head`としているコードもあった。
最終的には確かに逆順リストの先頭になるのだけど、途中ではそうではないのでどうなんだろうという気持ちがある。

# ステップ３

iterativeのほうを選択し３回連続で通せたので一旦完了。

# ステップ４

`node.next.next = node`を使う再帰も書いてみた。
