# ステップ１

前回の問題と違い、今回は「重複した値を持つノードを全て削除する」

前のように今いるノードの先を見て値が同じだったらその一個先に繋ぎかえて、という方法ではダメで
重複があったらそもそも今見ているノード自体も消さなければならない。

また今回は連結リストがNoneじゃなくてもNoneが返る可能性があることにも注意する。
例えば(1,1,1)は全て消えてNoneが返る。

「今見ているノード」と「直前に１個しかないことが確定したノード」を持っておいて、
今見ているノードとそのnextが同じ値だった場合、同じ値でなくなるかNoneになるまで今見ているノードを先まで進める。
そうでなければ、「直前に１個しかないことが確定したノード」のnextを「今見ているノード」に繋ぎ変えて、
「直前に１個しかないことが確定したノード」＝「今見ているノード」
として、今見ているノードは１個次に進める

ということを繰り返していけばいいのかなという感じがする。

ただし一番最初だけ「直前に１個しかないことが確定したノード」というのが存在しないので、
その辺はうまいこと処理してやる必要がある。

1回目WA:値の異なるノードまで読み進めることができていなかった
2回目WA:最後の要素が消えるときにNoneへの繋ぎかえができていなかった。(1,2,2) -> (1)になるケースなど。

とりあえずごり押しでACまでしたけど酷いコードなのでステップ２でロジックを整理してリファクタリングをする

# ステップ２

気になる点が３つ。

１つ目はstep1.pyで15行目のifと20行目のwhileで同じ条件を使っているところ。ここは整理できそうな気がする。
２つ目、whileだけで異なる値までいけなかったので無理やり25行目で１つ進めているところ。
３つ目は36行目で最後の要素が消えたときに無理やりつじつまを合わせている点。ここも不自然な感じがあるので何とかしたい。

１つ目について。そもそもif-elseで分岐させる必要が無くて、whileで同じ値じゃなくなるまで読み飛ばしを先にやってから
後続のelseの処理をそのまま持ってきたらいいだけのような気がする。

２つ目は最初に今の値をcurrent_valとかに保存しておいて、今見ているノードの値=current_valなら次に進めるっていう風にしたらよさそう。
current_valはややこしいか、start_valとか？
これだと最初に見たノードの値がユニークだったときに上手くいかないな…

やっぱり

1. 重複のあるノードを全部スキップする
2. 重複の無いノードなら前に確定したノードからつなぐ

って根本的に違う処理をしている気がするのでif-elseで分岐させた方がいいかもしれない。

３つ目も最後に重複があったら全部スキップするの後にwhileを抜けちゃうのでどうしてもwhileの外でそこをケアするしかないような気がする。

うーん、あまりコードが変わらなかった…。気になる点で対処できたのは２つ目くらい。

# ステップ３

他の人のコードを読んで勉強してみることにする。

https://github.com/t-ooka/leetcode/pull/11/files

ダミーノードを最初に用意しておくという手法がまずあるらしい。
そして、重複があるときに全部読み飛ばすのではなくて異なる値の１個手前で止まるようにする。
そうすると

1. previous_node.next = current_node だったらこれは読み飛ばしが起こらなかった＝重複が無いノードなのでそのまま残して次に進める
2. そうでなければ読み飛ばしが起こっているので previous_node.next = current_node.next に繋ぎかえて次に進める

とするとよいと。なるほど～～～。賢い。こうすると最後に重複があった場合も無理やりつじつまを合わせるみたいなこともしなくていいのか。
条件はちょっとややこしくなるけどこれは別にダミーノードを採用してなくても出来る…かな？

他の人のも少し見てみる。

https://github.com/5103246/LeetCode_Arai60/pull/4/files

こちらの最初の答えは「次のノード」と「２個先のノード」を見るというやり方でやっている。
今見ているノードも合わせると計３個のノードに気を配らなければいけないし実際考慮漏れなどもあったようなので、
この方法でバグらせずに書くのはなかなか難しそうだなという感じがする。

https://github.com/5103246/LeetCode_Arai60/pull/4#discussion_r2286681034
currentはあまり使わないらしい。previousとの比較にしても単にnodeでいいのかもしれない。

今思ったけどダミーノードのvalは-1でいいのだろうか…。問題文の制約には[-100,100]と書いているように見えるけど。
-1にしても通ってしまったな、ただ本来は-1000とか取りえない値にしたほうがよさそう。

previous_nodeという名前だけど、個人的にはpreviousだけだと元の連結リスト上の直前のノードという感じがしてしまうので、
最初に書いたようにprevious_unique_nodeみたいな名前にしたい気持ち。

GPTに相談してみたがuniqueは微妙そう。初期値がダミーではないので実体と違うと言われたけど、とり得ない値を入れるのだから
ユニークなのでは？と思うけど
「多くの読者は「unique＝入力リスト内で1回だけ出現する値」と読みます。ダミーは“入力の一部ではない”ので、概念的には別物です。」
と反論されてしまった。そうかあ。

提案された候補は

- prev_kept
- last_kept
- result_tail, tail

など。keptは保持したという意味が込められている感じかな。この中だとlast_kept_nodeとかがいいかもしれない。

# ステップ４

３回連続で通るようになったので終了。

ダミーノードの導入だったり重複があったときに異なる値の一個前のノードで止めてやるようにするなどの改善により、
最初に比べるとだいぶすっきりとしたコードになりすらすらと書けるようになった。
ロジックも分かりやすい気がする。

# ステップ５

レビュー後にいただいたコメントを元に復習。

## node, dummy だけの実装

まず、「last_kept_nodeは使わずにdummyとnodeだけで（かつdummyは動かさずに）実装できるか」について。
考えても分からなかったのでコメントをいただいた方の実装を参考にさせていただいた。

https://github.com/akmhmgc/arai60/commit/2985ca0c671607ecbb674dafca30d3b4fca68037

今見ているノード(node)は「既に確定しているノードを指している」というのがポイントで、dummyから始める。
１個先、２個先を比較して異なっていたら１個先は確定させてよいので単にnodeを一個進める。
そうでなければ重複があるノードなので可能な限り飛ばしていってnode.nextを異なる値になるノードにつなぎ変える。
dummyは動かしてないので最後はdummy.nextを返せばよい。

という感じだった。コードを読んだだけではすんなり理解できなかったので紙に書いてシミュレートしたりして理解できた。

書いてみて
`node is not None and node.next is not None and node.next.next is not None`
という条件が流石にくどすぎるなという気がした。

Googleのスタイルガイドは
> Always use if foo is None: (or is not None) to check for a None value. 
https://google.github.io/styleguide/pyguide.html#2144-decision

であるし、自分も可能な限りそうすることに賛成している。前の問題でもそう言った。
https://github.com/nanae772/leetcode-arai60/pull/4/files#diff-bc26adce864df1eaf570b905014840f1b32806ec4d15b04e6dd68497a5efa7d4R95-R100

けどここはあえて`node and node.next and node.next.next`にしてみようかと思う。
練習なのでいろんな書き方を試してみるのも良いだろうし、長くなりすぎないというメリットも確かにある。
nodeはListNode|None型なのでNone以外の変なfalthyの値が入らないという言い訳も一応ある。

## dummyを使わない実装

もう一つは私が最初に実装していたdummyを使わない実装について、odaさんのコメントより
条件分岐などを整理してもう少しシンプルに書けるのではないかということで再度実装してみる。

少し苦戦したが何とか実装できた

1. まず値が１つしかない場合の処理のほうを先にした。簡単な方を先にする。
2. continueを用いてelseを使わないことで、インデントを下げて読みやすくする。
3. 読み飛ばしを行った後に`node_without_duplicates.next = node`と繋ぎかえておく。
  1. そうすることでループの外で無理やりつじつまを合わせなくてよくなった。

dummyを使わない関係上やはり条件分岐は多くなるが、それでも最初に書いたstep2.pyより
見通しはだいぶ良くなった…気がする。
