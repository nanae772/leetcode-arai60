# ステップ１

与えられた括弧列が正当なものかを判定する問題。括弧は`(),{},[]`の3種類ある。

これの`()`しかないパターンの問題は有名で私も解いたことがある。
それを少し応用させればこの問題も解けそう。

最初にスタックを用意して文字列を先頭から1文字ずつ順に見ていき

1. `(, {, [` が来たらスタックに積む。
2. `)` が来たらスタックの一番上が`(`でなければ括弧の対応が取れてないのでFalseを返す。そうでなければスタックの一番上をpopする。
  a. `}, ]`が来たときも同様に処理する。

そして最後にスタックが空になっていればOK、という感じだ。

Pythonはリストがそのままスタックとして使える(append/popがO(1))。
https://docs.python.org/3.11/tutorial/datastructures.html#using-lists-as-stacks


WA無しでAC。WA出さなかったの初めてかも。

# ステップ２

step1では開き括弧かどうか、とか閉じ括弧と開き括弧が対応しているか、とかを愚直にやっていたが、
ここをもう少し分かりやすくする。

開き括弧かどうかは開き括弧の集合を作ってそれに入ってるかどうかで判定する。
閉じ括弧と開き括弧の対応はdictで対応付けておく。

stack.pop()の値はわざわざ変数に入れなくていいか。
そうするとif分岐の条件をまとめられる。

chは変数名として分かりにくい。ここでは括弧しか出てこないのでbracketにする。
`close_bracket_to_open_bracket`はちょっと冗長すぎるか？
bracketしか扱ってないのは上の変数名とあわせて分かりそう、`close_to_open`とかでいいかな？

うーん、なんか

```python
close_to_open = {")": "(", "}": "{", "]": "["}
```

といちいち手入力しなければいけないのが微妙に感じる…ぱっと見分かりづらいし、何回も書いてたらミスしそう。
ASCIIコードの足し引きで計算で求められたりしないだろうか。
と思って調べてみたけど、微妙に一貫性が無い…

```
>>> print(ord('('), ord(')'))
40 41
>>> print(ord('['), ord(']'))
91 93
>>> print(ord('{'), ord('}'))
123 125
```

https://ja.wikipedia.org/wiki/ASCII

[]の間には\、{}の間には|が挟まっているらしい。知らなかった。
`)`だったら-1、そうでなければ-2するとかで出来なくは無いが…流石に余計分かりづらそう。

念のためPythonの標準ライブラリに対応する括弧の文字を求める関数とかないかと調べてみたが無さそう。

他の人のコードを見る。

https://github.com/5103246/LeetCode_Arai60/pull/6/files

これを見て気づいたが開き括弧→閉じ括弧の対応にしてpopしたやつを閉じ括弧に変換して一致を見る方法がある。
そのほうがdictの初期化もいくらか分かりやすく書けるし、`open_brackets`という変数も要らなくなる。
気づかなかった。

プッシュダウンオートマトンやらチョムスキー階層やら難しい言葉が出てきている。
一応情報学科を卒業しており確かに習った記憶はあるが何がどういったものか全く説明できない。
時間があるときに復習をしたい。

stackというのは変数名をサボっているか、こっちの変数名を`open_brackets`にしよう。

# ステップ３

3回連続で通せるようになったので一旦完了。

# ステップ４

GPTにいろいろ教えてもらいながら再帰下降構文解析による解法も実装してみた。
なんとなく分かったような分からないような…まだ腹落ちはしていない。
