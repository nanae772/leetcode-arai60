## １段階目

まずは一番分かりやすい解法で解く。

リンクリストの先頭から順番に見ていって、見たノードをチェック済みとしてsetに格納する。
その過程で今見ているノードが既にチェック済みのsetにあれば、リストが循環しているということ
なのでその時点でTrueを返す。
最後まで見て、今見ているノードがNoneになったら循環が無い一直線のリストなのでFalseを返す。

この実装方針としては

1. hasCycleを再帰関数にして、チェック済みノード集合はインスタンスのメンバ変数として管理する
2. hasCycleを再帰関数にせずwhileループを使う、チェック済みノード集合は関数内変数として管理する

の２パターン思いつく。Pythonはネストの深い再帰処理があまり得意ではなく、またチェック済みノード集合を
インスタンスのメンバ変数として管理するのは煩雑になりそうだったため、2の方針で実装した。

この解法はO(N)のメモリを消費してしまうため、O(1)のメモリで済む方法も考える。

連結リストの最大長さが10^4と問題から分かっているので、ループ回数が10^4を超えたらサイクルがあるという
判定はできそうだがそれは正攻法では無さそう…。
しかし5分考えても分からないのでAraiさんの動画で答えを見ることにする。

fast-pointer, slow-pointerという２つのポインタを用意して
fastは1ステップごとに2ノード先に、slowは1ノード先に進んでいくようにする。
すると、1ステップごとにfastとslowは1ノードずつ離れていく。
ここでもし連結リストにサイクルがあればどこかのタイミングでfastが一周して
fastがslowを追いかけていく形になり今度は1ステップごとにfastとslowは1ノードずつ近づいていく形になる。
なのでどこかのタイミングでfastとslowが同じノードを指すステップが存在する。

一方で、連結リストにサイクルが無い場合は明らかにfastが先にゴールにたどりつき、
スタート以外でfastとslowが同じノードを指すステップは存在しない。

よってfastとslowを1ステップずつ進めていって

- fastがNoneにたどりついたらサイクルが無い
- fastがslowと同じノードにたどり着いたらサイクルがある

と判定できる…という感じらしい。

この考え方を元に実装をしてみる。

## ２段階目

３回連続で何も見ずに解けるようになったので一旦完了。
