# ステップ１

文字列の集まりが与えられるので、アナグラム（文字の入れ替え）で同じになるものをまとめるというタスク。

文字列がアナグラムで一致するかどうかは文字列の各文字をソートしたものが一致するかどうかを見ればよい。
なのでソートされた文字列をkeyとして、そのvalueを元の文字列の配列にすれば効率的にまとめられる。
今回はdefaultdictを使うと便利そう
https://docs.python.org/3/library/collections.html#collections.defaultdict

とりあえず書けた。

# ステップ２

他の解き方は無いか考えて、UnionFindでも解けるかなと思った。
ただUnionFindクラスを実装しなければならずUnionFindを使うメリットもそこまで無さそうなので止めておく。

問題自体はすぐ終わったので「エンジニアリングをする」という観点で、少しこのクラスを使う側の視点で考えてみる。
この関数も返り値の順序が割と適当だが、順序を決めるとしたらどういう順序だと使う側は嬉しいだろうか。
各グループの中身はシンプルにアルファベットの昇順がよさそう。
グループ間の順序は…要素数順が適切だろうか。
「この文字列の集まりをアナグラムでグルーピングしておいて」
といったときにどういうことを期待するんだろうか。
あまりユースケースが思いつかないが、何となくグループされた文字列が多いものを知りたいような気もするので
グループ間の順序をつけるとしたら要素数の降順？
でも降順はなんか不自然な気もするからやはり昇順が自然？
うーん、分からない。

有用性や一意性のためにソートするのは実行時間がかかることとのトレードオフにもなりそう。
要素数順のソートはそんなにかからないだろうが、各グループ間の文字列をアルファベット順にソートするには
全て１つのグループに入る場合の最悪を考えるとO(NMlogN)か。(N:文字列の数、M:1つの文字列の長さの最大)

他の人の解答も少し見る。

https://github.com/akmhmgc/arai60/pull/9/files

「各文字列が英小文字である」という条件が崩れた場合にどうなるか、というのも確かに考えておいたほうがいいのか。
step1の解法では文字列をソートするので多分問題は無さそうだが、
英小文字が26文字であることを利用して各文字をカウントしてカウント数で比較する
という手法を取っている場合は前提条件が崩れるとうまく動かなくなるということが起きる。

また26文字であることを利用した解法も考えてはいた。確かに計算量上はソートより優位であるけれど、
Pythonで文字列を１つずつ見ていってカウントして、という処理をするより、
Cで実装されている組み込みのsortを使ったほうがおそらく速いだろうという感覚だった。

https://github.com/h1rosaka/arai60/pull/16/files

defaultdictを実装されている方もいた。
勉強になりそうなので時間があるときにやってみてもいいかもしれない。

# ステップ３

３回連続で通せるようになったので一旦完了。
