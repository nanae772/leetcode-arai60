# ステップ１

昇順ソートされた２つの数列a, bから１つずつ取り出して和を取ったときに最小の和k個を求める

全てのペアで和を取ってソートしてk個取るという自明な解法はO(N^2logN)なので今回は難しそう
a[:k], b[:k]に絞ってやるとO(k^2logk)になって速い言語ならギリいける…？

なんかダイクストラっぽい（？）解法が思いついた

aのインデックスi, bのインデックスjのペアで構成される(i, j)を頂点に見立てたグラフを構築すると
パスカルの三角形の形のグラフが出来上がる。

    (0,0)
     /  \
  (1,0)(0,1)
   /  \ /   \
(2,0)(1,1)(0,2)

そして最小ヒープを用意しておく。
最初(0,0)の和をヒープに入れる。

そして以下をk回繰り返す。
ヒープから１つ取り出しその頂点を(i,j)とすると、そこから辿っていける頂点(i+1,j),(i,j+1)が次の最小の候補になるので
それらの和をヒープに突っ込む。そしてループの初めに戻る。

この方法が正しいか上手く証明できないけど、何となくできそうな気がする。
これをやると最小のペアがk個求められそう。この方法だとO(klogk)で出来るはず。

返り値をlist[tuple[int,int]]にしていたが、list[list[int]]が指定されていた。最初にちゃんと見ないといけなかった。

あー、(1,1)みたいに２回pushされるペアのことを考えていなかった…。
setを使って既にpushされているペアは入れないようにしよう。

とりあえずACできた

# ステップ２

自分で思いついた改善点は主に以下２つ。

1. index_num1, index_num2がやや冗長かも？ i_num1, i_num2 くらいでいいかも。
2. ヒープに突っ込むのは自前のデータクラスとか作ってやったほうがいいかも…？ __lt__, __gt__とか定義するのがちょっと面倒で最初はやらなかったが
   a. というか比較演算子をどこまで定義すればいいのかよく分かってない、後で調べる

`pushed_pairs`もやや書き手の都合の名前になってる気がする？
`seen_pairs, checked_pairs`のほうが自然？
Editorialでは`visited`になっていて確かに上のようにグラフとして見るとvisitedなんだけど、
読み手にとってそれはあまり自明ではない気がする。

https://github.com/h1rosaka/arai60/pull/14/files

このコードで「左に行くのはj=0の場合だけ」とすると各ペアを１回しか訪れないようにできるというのを見てなるほど！と思った。
これだと`seen_pairs`のようなsetを使わなくてよくなる、しかし少しコードを読み書きする際に注意が必要になりそう。

https://github.com/Yoshiki-Iwasa/Arai60/pull/9#discussion_r1647019606

他にもいろいろやり方があるようだ。

> (0, 0) のみを入れて、pop するたびに、その下と右を入れる、ただしもう入ったものは除く

これは今回自分が実装した方法

> はじめに (i, 0) をすべて入れて、(i, k) がでてくると (i, k + 1) を入れる

これは右に行くだけで全部行けるようにするということか

> (0, 0) のみを入れて、pop したものに対して、その下と右を入れる、ただ、その入れるものの、上と左がすでに出てきていなければ、入れる必要ないですね。

これはheapのサイズを削減する方法。なるほど。

github.com/TORUS0818/leetcode/pull/12#discussion_r1623354548

このsetを使わない方法はまだ理解できていない…

dataclassの比較について、order=Trueにして比較に使わないフィールドをcompare=Falseにするとよいとのこと
https://docs.python.org/ja/3.11/library/dataclasses.html

左と右に行くときに同じことをやってるので関数化したほうがよさそう

PairSumというデータクラスを使うと可読性はやや上がった気がするが100ms->183msと処理時間が増えてしまった。
オブジェクトの生成コストが結構バカにならない感じだろうか…
ちょっとおおげさな感じもするし最後はデータクラスは使わずにtupleでやることにする。

# ステップ３

３回連続で書けるようになったので一旦完了。
heappush(list, val)の際にlistを忘れてしまうことがまだある…。

# ステップ４

紙に書いて手でシミュレートしてみたりしてsetを使わずにヒープのサイズを削減する方法が何となく理解できたので実装してみる。

書いてみると割とシンプルだった。
next_i1, next_i2の意味するところが分かりづらいかと思ったのでコメントをつけた。
本当は変数名で分かるようにしたほうがいいのだろうけど、ちょっとどう名前をつければいいか分からなかった。
全部説明してしまうとめちゃくちゃ長い変数名になってしまいそうだし…。

ヒープのサイズを削減する方法、ヒープのサイズは削減できるがsetを使うにしろ使わないにしろ新たにO(N)のメモリが必要になるため、
どうなのだろうという気持ちはある。
ヒープのサイズを小さくしておくとpush, popにかかる時間は少し短くなるはずなのでそういったシチュエーションで使うのかな？
logなのでどれくらい効くのかは分からないけど。
