# ステップ１

数値の集まりを常に持ってて、新しい数値を入れるたびに「この中で今k番目に大きい数値は何ですか？」
というクエリに答えよという問題。

一番シンプルなやり方は数値を動的配列で持ち、新しい数値を入れるたびに降順ソートをかけて
k番目の要素を取ってくるという方法。これはクエリごとにソートが走るので全体の計算量は
O(Q(Q + N)log(Q + N))かかる(Qはクエリの数、Nは最初に与えられるnumsの要素数)。
問題からN = 10^4, Q = 10^4くらいにはなりそうなので多分この解だとTLEしそう。

maxHeap(一番大きい要素が常に先頭に来るデータ構造)を使えばk=1のときはクエリごとにO(log(Q+N))で処理できるので、
O((Q+N)log(Q+N))になっていけそうだが、k>1のときはどうしよう？

いや、逆か。minHeap(一番小さい要素が常に先頭に来るデータ構造)にして、heapのサイズをkまでにすればよさそう。
そうしたときにminHeapの先頭が今までに見た数値の中でk番目のものになってるようにすればいい。
新しい要素が来た時に、minHeapの先頭の要素以下だったらそれは絶対にk+1番目以降になるので無視してよくて、
先頭の要素より大きければ今の先頭をpopして、新しい要素をheapに詰め込んで最小になったものがk番目に大きいものになる。
これでいけそう。

Pythonでheapはheapqライブラリにあったかな…？
https://docs.python.org/ja/3.11/library/heapq.html

読んでみるとpushとpopを同時に行うheappushpopというものがあるらしい。
別々に行うよりも効率的に行えると書いているのでそちらを使ってみることにする。
https://docs.python.org/3.11/library/heapq.html#heapq.heappushpop

最初何回かheapqの基本的な使い方間違えてWA。
その後、最初に空だったり最初のpushで初めてk個になることを想定していなかったことに気づいた。

修正してとりあえず一回目AC

# ステップ２

問題を解くだけならこれでいいのかなという気持ちで、これをクラスとして見たときには
もうちょっと例外処理とかが必要なのかもしれないという気持ちがある。

- k >= 1 で入ってきてるか
- addした後にheapがk個になっているか（求められないものを求めようとしていないか）

くらいはチェックして条件にあってなかったらエラーを投げる、とかはあってもよさそう。

あとはmin_heapという名前はあまり良くないか。「上位k個の大きいもの」という意味でtop_k_largestとかでいいのかな。
min_heapっていう言葉が無いとtop_k_largest[0]が何を表しているかよく分からない気もする。
min_heap_of_top_k_largest？長い？

せっかくなので久しぶりに自分でもheapを実装してみようかな。
pushは一番下につけて親と大きさ比較して小さかったらswapするっていう単純なやり方でよかったはず。
popがちょっと分からないな…どうやるんだっけ。二分木だから左か右どっちかが先頭に来るんだけど、そのときにどうすれば
形を保ったまま先頭に持ってこれるんだっけ…。
https://ja.wikipedia.org/wiki/%E3%83%92%E3%83%BC%E3%83%97

ああ、先頭をヒープの一番最後と入れ替えて先頭を下ろしていけばいいのか。

heapq.pushpopの効率が良い理由もこれで分かった気がする。
push/popを分けてやると

1. 末尾にpushしてそれを上に上げていく
2. popするときに先頭を末尾と入れ替えて先頭から降ろしていく

となるけど一緒にやると

1. 末尾に加えてそれを先頭と入れ替えてから先頭を降ろしていく

とやればいいのでpushしたときの上に上げていく操作が必要無くなるからってことかな。
というか単に

1. 先頭をpushする要素で上書きしてそれを下に降ろしていく

だけでいいか。

後は与えられた配列を初期値としてヒープ化(heapify)する関数も一応あったほうがいいか。
これは下からボトムアップで部分木がヒープ条件を満たすように入れ替えたり降ろして行ったりを繰り返すといいらしい。
何となくO(NlogN)かかりそうだけど実際はO(N)になるとのこと。

https://qiita.com/gteu/items/f40bdee41dd6a272a47e

自分でヒープを実装できた。ヒープ自体のロジックの整理にも時間がかかったが、自前でデータ構造を作るとなると
どの程度までエラー処理をやるかなどもやっていたら時間が結構溶ける。
単体テストなども本当はちゃんと書くべきだと思うがキリが無いので一旦ここまでとしたい。

# ステップ３

３回連続で通せるようになったので一旦完了。

pythonはヒープというクラスがあるわけではなくheapqを通してリストをヒープに保つという操作なのでやや書き方が独特に感じる。
他の方のアドバイスに従いリントなどを切って補完も最小限にしているので、間違った書き方をしていないかに気を使った。

# ステップ４

レビューでいただいたコメントを元にMinHeapを改めて実装し直してみる。
前と変えた点は以下。

- Heapのキャパシティ(容量)を無くした
  - キャパシティがある方が実装しやすいと思ったが、他の方のコードを見ていてそんなに難しくなさそうだと思ったため
  - また実践的にはキャパシティが無いほうが扱いやすいため
- 汎用性を意識して型パラメータでジェネリクスっぽくしてみた
  - Pythonに型はそもそも無いが、mypy, pyrightなどの型チェッカーがあると実行前に異常を検知できるようになる
  - Pythonは型が無いのが長所でもあるので一長一短だが、自分はなるべく型があるほうが安心するため
  - ただし、この書き方だと[1, 2.1]のように「型は違うが比較できるもの」はダメというように見えてしまうので難しい
- (i - 1) // 2, 2 * i + 1 などハードコーディングしている部分をなるべく関数化した
- shift_up, heapify_subtree は再帰関数で書くようにした
  - Pythonで再帰を使うのはなるべく避けたほうがよいが、Heapは二分木なので再帰深さがせいぜい30もいかないだろうからこの場合は使っても問題無いだろうと判断した
  - そして可読性の面では再帰のほうが何をやっているか分かりやすい気がするので今回は再帰関数を使った

またKthLargestのほうもコンストラクタでnumsを全部self.addするというやり方を取ってるコードがあり、
そちらのほうが分かりやすいなと思ったのでそちらを採用した。
