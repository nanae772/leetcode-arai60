# ステップ１

前回の問題の連結リストのサイクル検出とほぼ同じ問題だが、
今回はサイクルの始点となるノードを返さなければいけない。

setを使って訪問済みノードを管理する方法であれば前回のコードを少し変えるだけで
簡単にサイクルの始点となるノードを返すことができる。
ただし、これはO(n)メモリーを使ってしまう。

前回学んだウサギと亀の方法は「ウサギが亀に追いついたらサイクルがある」という手法だったが、
それだけだとサイクルの始点までは分からないのでもう少し発展させる必要がありそう。

ウサギと亀が最初に出会ったところをスタートとして、もう一回出会うまでのステップ数がサイクルの長さになりそう？
でもサイクルの長さが分かったら始点が分かるのか…？

あー、サイクルの長さが分かれば(全体のノード数) - (サイクルの長さ)がサイクルでない部分なので、
連結リストの先頭からサイクルでない部分の長さ分進めばサイクルの始点にたどり着けるのか？
そんな気がする。それでやってみよう。

とりあえず前回同様

1. setを使った分かりやすい回答(O(n)メモリ)
2. Floyd's cycle detectionを使った回答(O(1)メモリ)

の２パターンまずは実装する。

2の方法を実装している途中で「サイクルがあるときにそもそも全体のノード数って分かるのか？」という問題を
全く考えていなかったことに気づいた。分からない…。うーん…。

先頭から順に「サイクル長さ分進んでいってスタート地点に戻ってこれたらそこがサイクルの始点」という
解法が思いついた。けど、これは時間計算量がO(n^2)になってしまうなぁ。
一応この方法で実装はしてみたら通りはした。

考え込んでしまった、流石にそろそろ答えを見たほうがよさそう。

答えを見ると衝突地点からslowを連結リストの先頭に戻し、fastはそのままの位置に置き、
1ステップごとにfastもslowも速さ1で進めていき、ぶつかったところがサイクルの始点になるとのこと。

言われてみれば納得ではあるがこれもなかなか思いつける気はしない。
証明の理解にもなかなか時間がかかった。

# ステップ２

最後に書いたstep1_const_memory.pyを採用して、
コードを読みやすくリファクタリングする。といってもコード量も少なく既にシンプルで読みやすいのではと思っている。

ただwhile-if-whileと三重にネストしているのでそこは少し追いづらいかもしれない。
１つの案としてはifの中の処理を「サイクルの始点を見つける関数」として切り出す、というのがある。
それを少し試してみる。

関数に切り出してみたが、やみくもにコード量が増えてただややこしくしてしまった感じがある。
detectCycleでしか使わない関数であるという点もあり、あまりメリットを感じなかった。

一応コードは `step2_const_memory.py` として残しておくが、次のステップではこの書き方ではなく
ステップ１で書いたものをそのまま使うことにする。

# ステップ３

３回連続で書けるようになったので完了。

条件分岐が複数あるからか`or`を`and`にしてしまったり`is`を`is not`にしてしまったり、というバグを
発生させてしまった。
